<!DOCTYPE html>
<html>

<head>
    <!-- meta charset="utf-8" -->
    <!-- meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" -->

    <script src="js/HP.js"></script>
    <script src="shaders/general.fsh"></script>
    <script src="shaders/frag.fsh"></script>

    <style>
        body {
            background-color: #333333;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            background-color: #fff;
            margin: 0px;
            overflow: hidden;
        }
    </style>

    <script type="module">

        import * as THREE from 'https://cdn.skypack.dev/three@v0.130.1';

        document.addEventListener("DOMContentLoaded", (event) => {
            init();
            animate();
        });

        var cvs1;
        var camera, scene, renderer, plane;
        var postCamera, postScene, target, usePost, grid;
        var uniforms, postUniforms, axisUniforms, axis;
        var winWidth, winHeight, frustumSize, camX, camY, camlr, camtb;

        const Me = {
            getAxisPoints: function () {
                return [
                    new THREE.Vector3(-10, 0, 0.2),
                    new THREE.Vector3(10, 0, 0.2),
                    new THREE.Vector3(10, -10, 0.2),
                    new THREE.Vector3(0, -10, 0.2),
                    new THREE.Vector3(0, 10, 0.2),
                ];
            },
            getGridPoints: function () {
                const points = [];
                for (var i = 0; i < 200; i += 2) {
                    const k = 0.2;
                    points.push(new THREE.Vector3(-10 + (i + 0) * k, -10.1, 0.1));
                    points.push(new THREE.Vector3(-10 + (i + 1) * k, -10.1, 0.1));
                    points.push(new THREE.Vector3(-10 + (i + 1) * k, +10.1, 0.1));
                    points.push(new THREE.Vector3(-10 + (i + 2) * k, +10.1, 0.1));
                }
                points.push(new THREE.Vector3(-10.1, 10.1, 0.1));
                for (var i = 0; i < 200; i += 2) {
                    const k = 0.2;
                    points.push(new THREE.Vector3(-10.1, -10 + (i + 0) * k, 0.1));
                    points.push(new THREE.Vector3(-10.1, -10 + (i + 1) * k, 0.1));
                    points.push(new THREE.Vector3(+10.1, -10 + (i + 1) * k, 0.1));
                    points.push(new THREE.Vector3(+10.1, -10 + (i + 2) * k, 0.1));
                }
                return points;
            },
            getFract: function (v, invmag) {
                return (v / invmag - Math.floor(v / invmag)) * invmag
            },
            log: function (b, n) {
                return Math.log(n) / Math.log(b);
            }
        }

        function init() {
            cvs1 = document.querySelector("#canvas1");
            winWidth = window.innerWidth;
            winHeight = window.innerHeight;
            camX = camY = 0;
            frustumSize = 8;

            renderer = new THREE.WebGLRenderer({ canvas: cvs1 });
            renderer.setClearColor(0x333333);
            renderer.setPixelRatio(window.devicePixelRatio);

            camera = new THREE.OrthographicCamera(1, 1, 1, 1, 0, 2);
            camera.position.z = 1;
            scene = new THREE.Scene();

            postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 2);
            postCamera.position.z = 1;
            postScene = new THREE.Scene();

            usePost = true;
            target = new THREE.WebGLRenderTarget(winWidth, winHeight, {
                texture: {
                    format: THREE.RGBFormat,
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    generateMipmaps: false
                },
                stencilBuffer: false
            });

            setupScene();
            setupPost();

            onWindowResize();
            window.addEventListener("resize", onWindowResize, false);
        }

        function setupScene() {

            // uniforms = {
            //     l: { value: [1, 582, 200, 0, 0] },
            //     b: { value: [1, 6552, 250, 0, 0] },
            //     sx: { value: [1, 10000, 0, 0, 0] },
            //     sy: { value: [1, 10000, 0, 0, 0] },
            //     cc: { value: 0 },
            //     iResolution: { value: [1.0, 1.0] }
            // };
            uniforms = {
                l: { value: HP.num(0) },
                b: { value: HP.num(0) },
                sx: { value: HP.num(1) },
                sy: { value: HP.num(1) },
                cc: { value: 0 },
                iResolution: { value: [1.0, 1.0] }
            };
            var material = new THREE.ShaderMaterial({
                vertexShader: vert().trim(),
                fragmentShader: frag().trim(),
                uniforms: uniforms
            });

            const radius = 8;
            const geometry = new THREE.PlaneGeometry(radius * 2 * 2, radius * 2);
            plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

        }

        function setupPost() {

            postUniforms = {
                tTexture: { value: target.texture },
                dx: { value: 0 },
                highlight: { value: 0.3 }
            }

            axisUniforms = {
                tTexture: { value: target.texture },
                dx: { value: 0 },
                highlight: { value: 1.0 }
            }

            var postQuad = new THREE.Mesh(
                new THREE.PlaneBufferGeometry(2, 2),
                new THREE.ShaderMaterial({
                    vertexShader: post_vert().trim(),
                    fragmentShader: post_frag().trim(),
                    uniforms: uniforms
                })
            );
            postScene.add(postQuad);

            grid = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(Me.getGridPoints()),
                new THREE.ShaderMaterial({
                    vertexShader: grid_vert().trim(),
                    fragmentShader: grid_frag().trim(),
                    uniforms: uniforms
                })
            );
            grid.matrixAutoUpdate = false;
            grid.matrix = new THREE.Matrix4();
            postScene.add(grid);

            axis = new THREE.Line(
                new THREE.BufferGeometry().setFromPoints(Me.getAxisPoints()),
                new THREE.ShaderMaterial({
                    vertexShader: grid_vert().trim(),
                    fragmentShader: grid_frag().trim(),
                    uniforms: uniforms
                })
            );
            axis.matrixAutoUpdate = false;
            axis.matrix = new THREE.Matrix4();
            postScene.add(axis);
        }

        function onWindowResize() {

            winWidth = window.innerWidth;
            winHeight = window.innerHeight;
            cvs1.width = winWidth - 200;
            cvs1.height = winHeight - 200;

            var aspect = winWidth / winHeight;
            camera.left = frustumSize * aspect / -2 + camX;
            camera.right = frustumSize * aspect / 2 + camX;
            camera.top = frustumSize / 2 + camY;
            camera.bottom = frustumSize / -2 + camY;
            camlr = camera.right - camera.left;
            camtb = camera.bottom - camera.top;
            // console.log(camlr);

            camera.updateProjectionMatrix();
            renderer.setSize(winWidth, winHeight);

            var dpr = renderer.getPixelRatio();
            target.setSize(winWidth * dpr, winHeight * dpr);

            // plane.geometry.vertices[1].x = camera.left;
            // plane.geometry.vertices[1].y = camera.bottom;
            // plane.geometry.vertices[0].x = camera.right;
            // plane.geometry.vertices[0].y = camera.bottom;
            // plane.geometry.vertices[2].x = camera.right;
            // plane.geometry.vertices[2].y = camera.top;
            // plane.geometry.vertices[3].x = camera.left;
            // plane.geometry.vertices[3].y = camera.top;
            // plane.geometry.verticesNeedUpdate = true;
            // console.log(plane.geometry);

            postUniforms.dx.value = 2 / winWidth;
            axisUniforms.dx.value = 2 / winWidth;

            const magstep = 10;
            const invmag = Math.pow(magstep, Math.floor(Me.log(magstep, camlr * 2.2)) - 1);

            grid.matrix.set(
                10 / camlr * invmag, 0, 0, -Me.getFract(camX, invmag) * 2 / camlr,
                0, 10 / camtb * invmag, 0, Me.getFract(camY, invmag) * 2 / camtb,
                0, 0, 1, 0,
                0, 0, 0, 1
            )
            axis.matrix.set(
                10 / camlr * Math.max(invmag, 1), 0, 0, -camX * 2 / camlr,
                0, 10 / camtb * Math.max(invmag, 1), 0, camY * 2 / camtb,
                0, 0, 1, 0,
                0, 0, 0, 1
            )

            uniforms.iResolution.value = [winWidth, winHeight];

        }

        function animate() {
            // renderer.setRenderTarget(usePost ? target : null);
            renderer.setRenderTarget(null);
            renderer.render(scene, camera);

            // if (usePost) {
            //     renderer.setRenderTarget(null);
            //     renderer.render(postScene, postCamera);
            // }

            // requestAnimationFrame(animate);
        }

        document.addEventListener("wheel", (event) => {
            var d = event.deltaY > 0 ? HP.num(1.1) : HP.num(0.9);
            var dcomp = event.deltaY > 0 ? HP.num(-0.1) : HP.num(0.1);
            var mouseX = HP.num(event.clientX / winWidth);
            var mouseY = HP.num(1 - event.clientY / winHeight);

            uniforms.l.value = HP.plus(uniforms.l.value,
                HP.mul(
                    uniforms.sx.value,
                    HP.mul(mouseX, dcomp)
                )
            );
            uniforms.b.value = HP.plus(uniforms.b.value,
                HP.mul(
                    uniforms.sy.value,
                    HP.mul(mouseY, dcomp)
                )
            );
            uniforms.sx.value = HP.mul(uniforms.sx.value, d);
            uniforms.sy.value = HP.mul(uniforms.sx.value, HP.num(winHeight / winWidth));

            // console.log(uniforms.sx.value);
            console.log(HP.show(uniforms.l.value));
            console.log(HP.show(uniforms.b.value));
            console.log(uniforms.cc.value -= event.deltaY / 100);
            // onWindowResize();
            requestAnimationFrame(animate);
        });

    </script>
</head>

<body>
    <canvas id="canvas1" width="" height="window.innerHeight"></canvas>
</body>

</html>